<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>❌R2000❌</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #f4f7fc;
            color: #333;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            box-sizing: border-box;
            transition: background-color 0.3s, color 0.3s;
        }
        .dark-mode {
            background-color: #2c3e50;
            color: #ecf0f1;
        }
        .dark-mode .timer-section {
            background-color: #2c3e50;
            color: #ecf0f1;
        }
        #lastTopUpAmount {
    font-size: 0.9em;
    color: #3498db;
    font-weight: 500;
    margin-left: 10px;
    transition: color 0.3s;
}

.dark-mode #lastTopUpAmount {
    color: #63b3ed;
}
        .container {
    width: 95%;
    max-width: 480px;
    background: #ffffff;
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
    display: flex;
    flex-direction: column;
    align-items: center;
    height: 600px; /* Set a fixed height */
    overflow: hidden; /* Prevent overflow */
}
        .dark-mode .container {
            background-color: #34495e;
        }
        .input-group {
            width: 100%;
            margin-bottom: 15px;
        }
        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 0.9em;
        }
        .input-group input {
            width: 95%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 8px;
            font-size: 1em;
            background-color: #f4f7fc;
            color: #333;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        .input-group input:focus {
            border-color: #3498db;
            box-shadow: 0 0 8px rgba(52, 152, 219, 0.5);
        }
        .buttons {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-top: 15px;
            align-items: center;
        }
        button {
            padding: 10px 10px;
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        button:hover {
            background: linear-gradient(135deg, #2980b9, #3498db);
            transform: translateY(-2px);
        }
        button:active {
            transform: translateY(0);
        }
        .dark-mode button {
            background: linear-gradient(135deg, #2980b9, #3498db);
        }
        .dark-mode button:hover {
            background: linear-gradient(135deg, #3498db, #2980b9);
        }
        .log {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 8px;
            max-height: 150px;
            overflow-y: auto;
            font-size: 0.9em;
            width: 100%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        .dark-mode .log {
            background-color: #2c3e50;
            color: #ecf0f1;
        }
        .log-entry {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        .switch-container {
    display: flex;
    justify-content: space-between; /* Space between left and right buttons */
    align-items: center; /* Vertically center buttons */
    width: 100%;
    margin-bottom: 15px;
}
.left-buttons {
    display: flex;
    gap: 10px; /* Space between buttons */
    align-items: center;
}
#dragButton {
    background: transparent !important;
    border: none !important;
    font-size: 1.5em;
    cursor: pointer;
    padding: 0;
    margin: 0 5px;
    transition: transform 0.3s ease, opacity 0.3s ease;
    outline: none !important;
    box-shadow: none !important;
    color: inherit;
}
.timer-toggle-button:hover, #dragButton:hover {
    transform: scale(1.2);
    opacity: 0.8;
}

/* Dark mode specific styling */
.dark-mode .timer-toggle-button,
.dark-mode #dragButton {
    color: #ecf0f1;
}

/* Active state for timer when visible */
.timer-toggle-button.active {
    color: #e74c3c;
}

.dark-mode .timer-toggle-button.active {
    color: #e74c3c;
}

.top-buttons {
    display: flex;
    gap: 10px; /* Space between undo/redo */
}
        
        .top-buttons button {
            font-size: 1.2em;
            height: 36px;
            width: 36px;
            padding: 0;
            line-height: 1;
            border-radius: 50%;
        }
        .top-buttons button:hover {
            background: linear-gradient(135deg, #7f8c8d, #95a5a6);
        }
        .timer-section {
            display: none;
            width: 100%;
            margin-top: 5px;
            padding: 15px;
            background-color: #ffffff;
            border-radius: 5px;
            text-align: center;
            align-items:center;
            box-sizing: border-box;
            transition: background-color 0.3s, color 0.3s;
        }
        .timer-section.active {
            display: block;
        }
        .timer {
            font-size: 2em;
            padding: 2px;
            font-weight: bold;
            margin-top: 1px;
            color: #e74c3c;
        }
        .Start-Timer {
            display: flex;
             justify-content: space-between;
        }
        #timerInput {
               width: 98%;
            align-items:center;
            padding: 10px;
               margin-left: -20px;
            border: 1px solid #ccc;
               border-radius: 8px;
            font-size: 1em;
            background-color: #f4f7fc;
        		color: #333;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
            transition: border-color 0.3s, box-shadow 0.3s;
            margin-bottom: 10px;
        }
        .collapsible{
            width: 91%;
            margin-top: 5px;
            padding: 15px;
            background: #2c3e50;
            color: white;
            border-radius: 5px;
            text-align: center;
        }
       .sync-timer {
            display: flex;
            justify-content: flex-start; /* Align to the left */
            margin-top: 10px; /* Space from the buttons */
            width: 100%; /* Ensure it spans across */
      }
        #syncTimerDisplay {
            font-size: 2em;
            font-weight: bold;
            margin-left: 10px; /* Optional: Add padding from the left edge */
            color: #e74c3c;
            display: none;
        }
        #refreshButton {
               padding: 10px 10px;
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            height: 40px;  /* Match the height of the done and clear buttons */
            display: none; /* Hide these elements by default */
        }
            .buttons {
               display: flex;
            align-items: center;
            gap: 10px; /* Space between buttons */
        }
        .toggle-pos {
            font-size: 1em;
            padding: 5px 10px;
            cursor: pointer;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s;
            margin-top: 20px Adjust margin to create some space */
        }
        .toggle-pos:hover {
            background-color: #2980b9;
        }
        .sync-timer {
               display: none; /* Initially hidden */
            margin-top: 10px;
            font-size: 1.5em;
            	font-weight: bold;
              color: #e74c3c;
        }
        .bottom-toggle {
            margin-top: 15px;
        }
        #togglePos {
               padding: 10px 10px;
            display: none; /* Initially hidden */
            margin-right: 20px
            transition: opacity 0.3s ease;
        }
        #togglePos.show {
            display: inline-block;
            opacity: 1;
        }
        .green-text {
    color: green;
}
/* Style for the select dropdown */
select {
    width: 100%; /* Full width */
    padding: 10px; /* Padding for better touch targets */
    border: 1px solid #ccc; /* Border color */
    border-radius: 8px; /* Rounded corners */
    background-color: #f4f7fc; /* Background color */
    color: #333; /* Text color */
    font-size: 1em; /* Font size */
}
/* Focus state for the select dropdown */
select:focus {
    border-color: #3498db; /* Border color on focus */
    box-shadow: 0 0 8px rgba(52, 152, 219, 0.5); /* Shadow on focus */
}
/* Dark mode styles for the select dropdown */
.dark-mode select {
    background-color: #34495e; /* Dark background */
    color: #ecf0f1; /* Light text color */
    border: 1px solid #7f8c8d; /* Darker border */
}


#dragButton:hover {
    background-color: #2980b9;
}
.profiles-container {
    max-width: 300px;
    min-width: 300px;
    background: #ffffff;
    padding: 15px;
    border-radius: 12px;
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
    height: 611px;
    overflow-y: auto;
    display: none;
}

.dark-mode .profiles-container {
    background-color: #34495e;
    color: #ecf0f1;
}


.dark-mode .profiles-container h3 {
    border-bottom: 1px solid #7f8c8d;
}

.profile-item {
    cursor: move; /* Change cursor to indicate draggable */
    user-select: none; /* Prevent text selection while dragging */
    padding: 8px;
    margin-bottom: 8px;
    border-radius: 6px;
    background-color: #f4f7fc;
    transition: transform 0.2s ease;
}
.profile-item.dragging {
    opacity: 0.5;
    background-color: rgba(52, 152, 219, 0.2);
    transform: scale(1.02);
}

.profile-item.over {
    border-top: 2px solid #3498db;
}
.dark-mode .profile-item {
    background-color: #2c3e50;
}

.profile-item:hover {
    background-color: #e1e8ed;
}

.dark-mode .profile-item:hover {
    background-color: #3d5166;
}

.profile-name {
    font-weight: bold;
}

.profile-balance {
    float: right;
    font-weight: 500;
    font-family: monospace;
}
.main-wrapper {
    display: flex;
    flex-direction: row;
    gap: 5px;
    max-width: 800px; /* Adjust as needed */
    width: 100%;
    justify-content: center;
}

.container {
    width: 100%;
    max-width: 400px;
    min-width: 400px;
    background: #ffffff;
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
    height: 600px;
    overflow: hidden;
}

.profiles-container {
    width: 500px; /* Changed from 250px to 300px */
    background: #ffffff;
    padding: 15px;
    border-radius: 12px;
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
    height: 600px;
    overflow-y: auto;
    display: none; /* Hidden by default */
}

#startTimerButton, #stopTimerButton {
    background: transparent !important;
    border: none !important;
    font-size: 1.5em;
    cursor: pointer;
    padding: 0;
    margin: 0 5px;
    transition: transform 0.3s ease, opacity 0.3s ease;
    outline: none !important;
    box-shadow: none !important;
    color: inherit;
}

#startTimerButton:hover, #stopTimerButton:hover {
    transform: scale(1.2);
    opacity: 0.8;
}

/* Dark mode adjustments */
.dark-mode #startTimerButton,
.dark-mode #stopTimerButton {
    color: #ecf0f1;
}

/* Dark mode styles */
.dark-mode .main-wrapper > div {
    background-color: #34495e;
}

/* Rest of your existing dark mode styles... */

/* Make it responsive */
@media (max-width: 1000px) {
    .main-wrapper {
        flex-direction: column;
        align-items: center;
        max-width: 480px !important;
    }
    

    #toggleProfilesButton {
        display: flex; /* Always show toggle button on mobile */
    }
}

#toggleProfilesButton:hover {
    background: linear-gradient(135deg, #2980b9, #3498db);
    transform: translateY(-2px);
}

.dark-mode #toggleProfilesButton {
    background: linear-gradient(135deg, #2980b9, #3498db);
}

.dark-mode #toggleProfilesButton:hover {
    background: linear-gradient(135deg, #3498db, #2980b9);
}
.filter-controls {
    display: flex;
    gap: 10px;
    margin-bottom: 10px;
    align-items: center; /* Ensures elements align properly */
}

.large-dropdown {
    width: 80px; /* Adjust width as needed */
    height: 40px; /* Adjust height as needed */
    padding: 8px 12px; /* More padding for better appearance */
    font-size: 16px; /* Larger text */
    border: 1px solid #ccc;
    border-radius: 4px;
    background-color: white;
}

#profileFilter {
	width: 20px; /* Adjust width as needed */

    height: 20px; /* Match dropdown height */
    padding: 8px 12px; /* Consistent padding */
    font-size: 16px; /* Consistent font size */
    border: 1px solid #ccc;
    border-radius: 4px;
    flex-grow: 1; /* Takes remaining space */
}


.profile-item {
    padding: 10px;
    margin-bottom: 8px;
    border-radius: 6px;
    background-color: #f0f4f8; /* Lighter background for better contrast */
    cursor: pointer;
    transition: background-color 0.3s;
    color: #2d3748; /* Darker text color */
    border: 1px solid #e2e8f0; /* Add subtle border */
}

.dark-mode .profile-item {
    background-color: #2d3748;
    color: #f7fafc;
    border-color: #4a5568;
}
.profile-item:hover {
    background-color: #e1e8ed;
}

.dark-mode .profile-item:hover {
    background-color: #3d5166;
}

.selected-profile {
    background-color: #ebf8ff !important; /* Light blue background */
    color: #2b6cb0 !important; /* Dark blue text */
    font-weight: 500;
    border: 1px solid #90cdf4 !important;
}
.dark-mode .selected-profile {
    background-color: #2c5282 !important; /* Darker blue */
    color: #ebf8ff !important;
    border-color: #4299e1 !important;
}


.profile-item {
    padding: 10px;
    margin: 5px 0;
    border-radius: 5px;
    transition: background-color 0.2s;
}

.profile-item:hover {
    background-color: #f0f0f0;
}



.dark-mode .profile-item:hover {
    background-color: #3d5166;
}


.profile-item {
    display: flex;
    align-items: center;
    padding: 10px;
    margin: 5px 0;
    border-radius: 5px;
}

.profile-item {
    display: flex;
    align-items: center;
    padding: 10px;
    margin: 5px 0;
    border-radius: 5px;
    transition: background 0.2s;
    cursor: pointer;
}

.profile-checkbox {
    position: relative;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    min-width: 22px;
    min-height: 22px;
    border: 2px solid #3498db;
    border-radius: 4px;
    margin-right: 10px;
    cursor: pointer;
    outline: none;
    vertical-align: middle;
}

.profile-checkbox:checked {
    background-color: #3498db;
}
.profile-checkbox:checked::after {
    content: "✓";
    position: absolute;
    color: white;
    font-size: 16px;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
}

.dark-mode .profile-checkbox {
    border-color: #63b3ed;
}

.dark-mode .profile-checkbox:checked {
    background-color: #63b3ed;
}
.profile-info {
    display: flex;
    flex-grow: 1;
    pointer-events: none; /* Make the rest of the area clickable */
}

.profile-info > * {
    pointer-events: auto; /* But allow clicks on child elements */
}

.profile-name {
    font-weight: 600; /* Make text slightly bolder */
    flex-grow: 1;
}

.profile-balance {
    font-family: monospace;
    margin-left: 10px;
    font-weight: 500;
}

.selected-profile {
    background-color: rgba(52, 152, 219, 0.2);
}
#copy-message {
    position: fixed;
    bottom: 20px;
    left: 0;
    right: 0;
    margin: 0 auto;
    width: fit-content;
    background: #3498db;
    color: white;
    padding: 10px 20px;
    border-radius: 5px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    z-index: 1000;
    text-align: center;
    display: none; /* Hidden by default */
    max-width: 80%;
    word-break: break-all;
}
/* First Button - Blue */
#balanceTypeButton {
    width: 60px;
    height: 40px;
    font-size: 16px;
    background-color: #3498db; /* Solid blue */
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    font-weight: 500;
}
#balanceTypeButton.last-state {
    background-color: #e67e22 !important; /* Solid orange */
    color: white;
}
#balanceTypeButton.last-state:hover {
    background-color: #d35400; /* Darker orange */
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

/* Hover Effects */
#balanceTypeButton:hover {
    background-color: #2980b9; /* Darker blue */
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

#balanceTypeButton.last-state:hover {
    background-color: #c0392b; /* Darker red */
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

/* Active/Pressed Effect */
#balanceTypeButton:active,
#balanceTypeButton.last-state:active {
    transform: translateY(0);
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

/* Dark Mode Adjustments */
.dark-mode #balanceTypeButton {
    background-color: #3498db;
}


.dark-mode #balanceTypeButton:hover {
    background-color: #2980b9;
}

.dark-mode #balanceTypeButton.last-state:hover {
    background-color: #c0392b;
}
#selectAllButton, #copyProfilesButton {
    width: 60px;
    height: 40px;
    font-size: 16px;
    background-color: white;
    border: 1px solid #ccc;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.3s;
    display: flex;
    justify-content: center;
    align-items: center;
}
#copyProfilesButton {
    width: 35px;
    height: 40px;
    font-size: 16px;
    background-color: white;
    border: 1px solid #ccc;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.3s;
    display: flex;
    justify-content: center;
    align-items: center;
}
.profiles-header button:hover {
    transform: scale(1.1);
    background-color: rgba(52, 152, 219, 0.1) !important;
}

.dark-mode .profiles-header button {
    color: #63b3ed;
}

.dark-mode .profiles-header button:hover {
    background-color: rgba(99, 179, 237, 0.2) !important;
}

#copyToggleButton {
    font-size: 1.1em; /* Slightly smaller than position toggle */
    padding: 5px 2px; /* Tighter padding */
}

.profiles-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 5px; /* Reduced gap between buttons */
}
.profiles-header button {
    background: transparent !important;
    border: none !important;
    font-size: 1.2em;
    cursor: pointer;
    padding: 5px;
    transition: transform 0.3s, background-color 0.3s;
    outline: none !important;
    box-shadow: none !important;
    margin: 0;
}
.dark-mode .profiles-header {
    border-bottom: 1px solid #7f8c8d;
}

#togglePositionButton {
    color: #3498db; /* Blue in light mode */
    background: none;
    border: none;
    cursor: pointer;
    font-size: 1.2em;
    padding: 5px;
    border-radius: 4px;
    transition: transform 0.3s, background-color 0.3s;
}

#togglePositionButton:hover {
    transform: scale(1.1);
    background-color: rgba(52, 152, 219, 0.1);
}

.dark-mode #togglePositionButton {
    color: #63b3ed; /* Lighter blue for better visibility */
}

.dark-mode #togglePositionButton:hover {
    background-color: rgba(99, 179, 237, 0.2);
}

/* Add this to your existing .main-wrapper styles */
.main-wrapper {
    display: flex;
    flex-direction: row;
    max-width: 800px;
    width: 100%;
    justify-content: center;
    position: relative; /* Add this */
}

/* Add this new class */
.profiles-right {
    flex-direction: row;
}

.profiles-left {
    flex-direction: row-reverse;
}
.theme-toggle {
    width: 20px;
    background: transparent !important;
    border: none !important;
    font-size: 2em; /* Slightly smaller than emoji version */
    cursor: pointer;
    padding: 0;
    margin: 0 10px;
    transition: transform 0.3s ease, opacity 0.3s ease;
    outline: none !important;
    box-shadow: none !important;
    color: inherit; /* Inherits text color from parent */
}

.theme-toggle:hover {
    transform: scale(1.2);
    opacity: 0.8;
}

/* Dark mode specific styling */
.dark-mode .theme-toggle {
    color: #ecf0f1;
}

/* Remove any focus styles */
.theme-toggle:focus {
    outline: none !important;
    box-shadow: none !important;
}
.timer-toggle-button {
    background: transparent !important;
    border: none !important;
    font-size: 1.5em;
    cursor: pointer;
    padding: 0;
    margin: 0 5px;
    transition: transform 0.3s ease, opacity 0.3s ease;
    outline: none !important;
    box-shadow: none !important;
    color: inherit;
}

.timer-toggle-button:hover {
    background: linear-gradient(135deg, #2980b9, #3498db);
    transform: translateY(-2px);
}

.timer-toggle-button.active {
    background: linear-gradient(135deg, #e74c3c, #c0392b);
}

.dark-mode .timer-toggle-button {
    background: linear-gradient(135deg, #2980b9, #3498db);
}

.dark-mode .timer-toggle-button:hover {
    background: linear-gradient(135deg, #3498db, #2980b9);
}

.dark-mode .timer-toggle-button.active {
    background: linear-gradient(135deg, #c0392b, #e74c3c);
}
/* First State - Blue */
#balanceTypeButton {
    background-color: #3498db !important; /* Blue */
    color: white !important;
    border: none !important;
    transition: background-color 0.3s ease;
}

/* Last State - Orange */
#balanceTypeButton.last-state {
    background-color: #e67e22 !important; /* Orange */
    color: white !important;
}

/* Hover Effects */
#balanceTypeButton:hover {
    background-color: #2980b9 !important; /* Darker Blue */
    transform: translateY(-1px);
}

#balanceTypeButton.last-state:hover {
    background-color: #d35400 !important; /* Darker Orange */
}

/* Dark Mode Adjustments */
.dark-mode #balanceTypeButton {
    background-color: #3498db !important;
}

.dark-mode #balanceTypeButton.last-state {
    background-color: #e67e22 !important;
}
#copyToggleButton {
    background: transparent !important;
    border: none !important;
    font-size: 1.5em;
    cursor: pointer;
    padding: 0;
    margin: 0 5px;
    transition: transform 0.3s ease, opacity 0.3s ease;
    outline: none !important;
    box-shadow: none !important;
    color: inherit;
}

#copyToggleButton:hover {
    transform: scale(1.2);
    opacity: 0.8;
}

.dark-mode #copyToggleButton {
    color: #ecf0f1;
}
    </style>
<body>
 <div class="main-wrapper">

    <div class="container">
        <div class="switch-container">
            <!-- Left-aligned buttons (Dark Mode + Timer + Drag) -->
            <div class="left-buttons">
                <button id="darkModeButton" class="theme-toggle" aria-label="Toggle dark mode">☾</button>       
                <button id="timerToggleButton" class="timer-toggle-button">⏱️</button>
                <button id="dragButton" title="Drag to move">✥</button>
            </div>
            
            <!-- Right-aligned buttons (Undo + Redo) -->
            <div class="top-buttons">
                <button id="undoButton">⮌</button>
                <button id="redoButton">⮎</button>
            </div>
        </div>
        <!-- Collapsible Timer Section -->
        <div class="timer-section" id="timerSection">
            <input type="number" id="timerInput" placeholder="Enter minutes" min="1">
      <div class="Start-Timer "> 
          <button id="startTimerButton">▶️</button>
                   <div class="timer" id="timerDisplay">00:00</div>
          <button id="stopTimerButton">🗑️</button>
      </div>
        </div>
<div class="input-group">
    <div style="display: flex; justify-content: space-between;">
        <select id="profileSelect" style="justify-items: start"></select>
                    <button id="deleteProfileButton">✖️</button> 
            <button id="createProfileButton">➕</button>
    </div>
    <input type="text" id="currentBalance" placeholder="Enter current balance" style="margin-top: 10px;">
<div style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
    <div style="display: flex; align-items: center; gap: 5px;">
        <button id="addToCurrentBalanceButton">TOP UP</button>
        <span id="lastTopUpAmount" class="last-topup-display"></span>
    </div>
    <button id="toggleProfilesButton" title="Show/Hide profiles">👥</button>
</div>
</div>

        <div class="input-group">
            <label for="feeBox">Fee</label>
            <input type="text" id="feeBox" placeholder="Enter fee">
        </div>
        <div class="input-group" style="display:none;">
            <label for="transactionAmount">Transaction Amount</label>
            <input type="text" id="transactionAmount" placeholder="Enter transaction amount">
        </div>
        <div class="input-group">
            <label for="result">Result</label>
            <input type="text" id="result" readonly="">
        </div>
        <div class="buttons">
               <button class="done-button" id="doneButton">Done</button>
               <button class="toggle-pos" id="togglePos">👁</button>
            <button class="refresh-button" id="refreshButton">🗘</button>
            <button class="clear-button" id="clearButton">Clear</button>
        </div>
        <div class="sync-timer" id="syncTimer">
            <div id="syncTimerDisplay"></div>
        </div>
        <!-- Log Section -->
        <div class="log" id="log"></div>
        <!-- Refresh Symbol Button -->
    </div>
<div class="profiles-container">
<div class="profiles-header">
    <div class="header-buttons">
        <button id="togglePositionButton" title="Toggle position">⇄</button>
        <button id="copyToggleButton" title="Toggle 13-char copy on profile switch">☺</button>
    </div>
    <h3>All Profiles</h3>
</div> 
    <div class="filter-controls">
    <button id="balanceTypeButton" class="large-dropdown">First</button>

    <input type="text" id="profileFilter" placeholder="BO ID">
    <button id="selectAllButton" title="Select all profiles">✓ All</button>
    <button id="copyProfilesButton" title="Copy all profiles">🗒️</button>
</div>
    <div id="profilesList"></div>
</div>
</div>
<script>
    const currentBalanceInput = document.getElementById('currentBalance');
    const feeBoxInput = document.getElementById('feeBox');
    const transactionAmountInput = document.getElementById('transactionAmount');
    const resultInput = document.getElementById('result');
    const logDiv = document.getElementById('log');
    const doneButton = document.getElementById('doneButton');
    const clearButton = document.getElementById('clearButton');
    const undoButton = document.getElementById('undoButton');
    const redoButton = document.getElementById('redoButton');
    const darkModeSwitch = document.getElementById('darkModeSwitch');
    const timerInput = document.getElementById('timerInput');
    const startTimerButton = document.getElementById('startTimerButton');
    const stopTimerButton = document.getElementById('stopTimerButton');
    const refreshButton = document.getElementById('refreshButton');
    const timerSection = document.getElementById('timerSection');
    const timerDisplay = document.getElementById('timerDisplay');
    const syncTimerDisplay = document.getElementById('syncTimerDisplay');
    const timerToggleButton = document.getElementById('timerToggleButton');    const toggleSwitch = document.querySelector('.toggle-switch input[type="checkbox"]');
    let history = [];
    let redoHistory = [];
    let timerInterval;
    let isTimerRunning = false;

    // Function to format number with commas
    function formatNumberWithCommas(number) {
        return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    }

    // Function to handle input formatting
    function handleInputFormatting(input) {
        input.addEventListener('input', function () {
            let value = input.value.replace(/,/g, '');
            if (!isNaN(value) && value !== '') {
                input.value = formatNumberWithCommas(parseFloat(value));
            }
        });
    }
let lastTopUpAmount = 0;

    // Apply formatting to all input fields
    handleInputFormatting(currentBalanceInput);
    handleInputFormatting(feeBoxInput);
    handleInputFormatting(transactionAmountInput);

    timerToggleButton.addEventListener('click', function() {
    // Toggle the timer section visibility
    timerSection.classList.toggle('active');
    
    // Toggle the button's active state
    this.classList.toggle('active');
    
    // Update button text based on state
    if (timerSection.classList.contains('active')) {
        this.innerHTML = '⏱️';
        // If you want to auto-focus the input when opened:
        document.getElementById('timerInput').focus();
    } else {
        this.innerHTML = '⏱️';
    }
    
    // Save the state if needed
    saveAllData();
});

    timerInput.addEventListener('input', function () {
        const inputValue = parseInt(timerInput.value);
        if (!isNaN(inputValue) && inputValue > 0) {
            const min = inputValue.toString().padStart(2, '0');
            const timeString = `${min}:00`;
            timerDisplay.textContent = timeString;
            syncTimerDisplay.textContent = timeString;
            syncTimerDisplay.style.display = 'block';
            refreshButton.style.display = 'inline-block';
            document.getElementById('togglePos').style.display = 'inline-block';
        } else {
            timerDisplay.textContent = "00:00";
            syncTimerDisplay.textContent = "00:00";
            syncTimerDisplay.style.display = 'none';
            refreshButton.style.display = 'none';
            document.getElementById('togglePos').style.display = 'none';
        }
    });

    // Timer functionality
    function startTimer(minutes) {
        let time = minutes * 60;
        if (isTimerRunning) return;
        isTimerRunning = true;
        updateTimerDisplay(time);
        time--;
        timerInterval = setInterval(() => {
            if (time < 0) {
                clearInterval(timerInterval);
                isTimerRunning = false;
            } else {
                updateTimerDisplay(time);
                time--;
            }
        }, 1000);
    }

    function updateTimerDisplay(time) {
        let min = Math.floor(time / 60);
        let sec = time % 60;
        timerDisplay.textContent = `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
        syncTimerDisplay.textContent = `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
    }

    function resetTimer() {
        clearInterval(timerInterval);
        timerDisplay.textContent = "00:00";
        syncTimerDisplay.textContent = "00:00";
        isTimerRunning = false;
    }

    function handleTimerStart() {
        const minutes = parseInt(timerInput.value);
        if (!isNaN(minutes) && minutes > 0) {
            resetTimer();
            startTimer(minutes);
        } else {
            alert("Please enter a valid number of minutes.");
        }
    }
// Add this with your other global variables
let autoCopyEnabled = false; // Default to false (☺)

// Add this function to handle the toggle
function toggleAutoCopy() {
    autoCopyEnabled = !autoCopyEnabled;
    document.getElementById('copyToggleButton').textContent = autoCopyEnabled ? '☻' : '☺';
    localStorage.setItem('autoCopyEnabled', autoCopyEnabled);
}
    startTimerButton.addEventListener('click', handleTimerStart);
    refreshButton.addEventListener('click', handleTimerStart);

    stopTimerButton.addEventListener('click', () => {
        resetTimer();
        timerInput.value = '';
        syncTimerDisplay.style.display = 'none';
        refreshButton.style.display = 'none';
        document.getElementById('togglePos').style.display = 'none';
    });

    // Function to save the current state
    function saveCurrentState() {
        return {
            currentBalance: currentBalanceInput.value,
            fee: feeBoxInput.value,
            transactionAmount: transactionAmountInput.value,
            result: resultInput.value,
            logEntries: logDiv.innerHTML
        };
    }

    // Undo Button Event Listener
   undoButton.addEventListener('click', () => {
    if (history.length > 0) {
        const lastState = history.pop();
        redoHistory.push(saveCurrentState());

        currentBalanceInput.value = lastState.currentBalance;
        feeBoxInput.value = lastState.fee;
        transactionAmountInput.value = lastState.transactionAmount;
        resultInput.value = lastState.result;
        
        // Restore the log entries from the history state
        logDiv.innerHTML = lastState.logEntries;

        saveCurrentProfileState();
        updateProfilesList();
    }
});

    // Redo Button Event Listener
    redoButton.addEventListener('click', () => {
        if (redoHistory.length > 0) {
            const redoState = redoHistory.pop();
            history.push(saveCurrentState());

            currentBalanceInput.value = redoState.currentBalance;
            feeBoxInput.value = redoState.fee;
            transactionAmountInput.value = redoState.transactionAmount;
            resultInput.value = redoState.result;
            logDiv.innerHTML = redoState.logEntries;

            saveCurrentProfileState();
            updateProfilesList(); // Added to update profile list
        }
    });

// Clear Button Event Listener - Modified to clear all saved data
// Add these variables at the top with your other global variables
let backupData = null;
let isCleared = false;

// Modified Clear Button Event Listener
clearButton.addEventListener('click', async () => {
    if (!isCleared) {
        // First click - backup and clear data
        backupData = {
            currentBalance: currentBalanceInput.value,
            fee: feeBoxInput.value,
            transactionAmount: transactionAmountInput.value,
            result: resultInput.value,
            logEntries: logDiv.innerHTML,
            history: [...history],
            redoHistory: [...redoHistory],
            profiles: JSON.parse(JSON.stringify(profiles)), // Deep clone
            currentProfileIndex: currentProfileIndex,
            timerInput: timerInput.value,
            timerDisplay: timerDisplay.textContent,
            syncTimerDisplay: syncTimerDisplay.textContent,
            isTimerRunning: isTimerRunning
        };

        // Clear all data
        currentBalanceInput.value = '';
        feeBoxInput.value = '';
        transactionAmountInput.value = '';
        resultInput.value = '';
        logDiv.innerHTML = '';
        history = [];
        redoHistory = [];
        profiles = [];
        currentProfileIndex = null;
        resetTimer();
        timerInput.value = '';
        
        // Update UI
        updateProfileSelect();
        updateProfilesList();
        
        // Change button text and state
        clearButton.textContent = 'Restore';
        isCleared = true;
        
        showCopyMessage("All data cleared - click again to restore");
    } else {
        // Second click - restore data
        if (backupData) {
            currentBalanceInput.value = backupData.currentBalance;
            feeBoxInput.value = backupData.fee;
            transactionAmountInput.value = backupData.transactionAmount;
            resultInput.value = backupData.result;
            logDiv.innerHTML = backupData.logEntries;
            history = [...backupData.history];
            redoHistory = [...backupData.redoHistory];
            profiles = JSON.parse(JSON.stringify(backupData.profiles)); // Deep clone
            currentProfileIndex = backupData.currentProfileIndex;
            timerInput.value = backupData.timerInput;
            timerDisplay.textContent = backupData.timerDisplay;
            syncTimerDisplay.textContent = backupData.syncTimerDisplay;
            
            if (backupData.isTimerRunning) {
                handleTimerStart();
            }
            
            // Update UI
            updateProfileSelect();
            updateProfilesList();
            
            // Change button text and state
            clearButton.textContent = 'Clear';
            isCleared = false;
            
            showCopyMessage("All data restored");
        }
    }
});

    // Dark Mode Switch Event Listener
    if (document.body.classList.contains('dark-mode')) {
    darkModeButton.textContent = '☾';
} else {
    darkModeButton.textContent = '☀︎';
}

// Toggle handler
darkModeButton.addEventListener('click', () => {
    document.body.classList.toggle('dark-mode');
    if (document.body.classList.contains('dark-mode')) {
        darkModeButton.textContent = '☾';
    } else {
        darkModeButton.textContent = '☀︎';
    }
    saveAllData();
});

    // Toggle POS Button Event Listener
    document.getElementById('togglePos').addEventListener('click', function () {
        const syncTimer = document.getElementById('syncTimer');
        syncTimer.style.display = syncTimer.style.display === 'none' ? 'block' : 'none';
    });

    // Profile Management
    let profiles = [];
    let currentProfileIndex = 0;

function createProfile() {
    const profileName = prompt("Enter profile name:");
    if (profileName && profileName.trim() !== "") {
        const newProfile = {
            name: profileName,
            balance: 0,
            fee: 0,
            transactionAmount: 0,
            history: [],
            redoHistory: [],
            logEntries: ''
        };
        profiles.push(newProfile);
        updateProfileSelect();
        
        // Reset the Clear/Restore button if it was in "Restore" state
        if (isCleared) {
            clearButton.textContent = 'Clear';
            isCleared = false;
            backupData = null; // Clear the backup since we're working with new data
        }

        const profileSelect = document.getElementById('profileSelect');
        profileSelect.value = profiles.length - 1;
        switchProfile(profiles.length - 1);
        updateProfilesList();
    }
}
    function updateProfileSelect() {
        const profileSelect = document.getElementById('profileSelect');
        profileSelect.innerHTML = '';
        if (profiles.length === 0) {
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Current Balance';
            profileSelect.appendChild(defaultOption);
        } else {
            profiles.forEach((profile, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = profile.name;
                profileSelect.appendChild(option);
            });
        }
    }
// Updated switchProfile function
function switchProfile(index) {
    saveCurrentProfileState();
    currentProfileIndex = index;
    const currentProfile = profiles[currentProfileIndex];
    
    currentBalanceInput.value = currentProfile.balance ? formatNumberWithCommas(currentProfile.balance) : '';
    feeBoxInput.value = currentProfile.fee ? formatNumberWithCommas(currentProfile.fee) : '';
    transactionAmountInput.value = currentProfile.transactionAmount ? formatNumberWithCommas(currentProfile.transactionAmount) : '';
    resultInput.value = '';
    logDiv.innerHTML = currentProfile.logEntries || '';  // Ensure log is restored
    
    history = currentProfile.history ? [...currentProfile.history] : [];
    redoHistory = currentProfile.redoHistory ? [...currentProfile.redoHistory] : [];
    
    // Update last top-up display for this profile
    lastTopUpAmount = currentProfile.lastTopUpAmount || 0;
    updateLastTopUpDisplay();
    
    if (isCleared) {
        clearButton.textContent = 'Clear';
        isCleared = false;
        backupData = null;
    }
    
    if (autoCopyEnabled) {
        extractAndCopy15CharSegment(currentProfile.name);
    }
    
    saveAllData();
    updateProfilesList();
}

function updateLastTopUpDisplay() {
    const displayElement = document.getElementById('lastTopUpAmount');
    if (lastTopUpAmount > 0) {
        displayElement.textContent = formatNumberWithCommas(lastTopUpAmount);
        displayElement.style.display = 'inline-block';
    } else {
        displayElement.style.display = 'none';
    }
}


// Add event listener for the toggle button (add this with your other event listeners)
document.getElementById('copyToggleButton').addEventListener('click', toggleAutoCopy);
// Helper function to split and copy the 15-character segment
async function extractAndCopy15CharSegment(profileName) {
    // Split by space, hyphen, or underscore
    const segments = profileName.split(/[\s\-_]/);
    
    // Find the first segment with exactly 15 characters
    const targetSegment = segments.find(segment => segment.length === 15);
    
    if (targetSegment) {
        try {
            await navigator.clipboard.writeText(targetSegment);
            showCopyMessage(`Copied: ${targetSegment}`);
        } catch (err) {
            console.error("Failed to copy segment:", err);
            showCopyMessage("Failed to copy segment");
        }
    } else {
        console.log("No 15-character segment found");
        showCopyMessage("No 15-character segment found");
    }
}

// Helper function to show temporary messages
function showTempMessage(message) {
    const msgElement = document.createElement('div');
    msgElement.className = 'temp-message';
    msgElement.textContent = message;
    document.body.appendChild(msgElement);
    
    setTimeout(() => {
        msgElement.remove();
    }, 2000);
}

    document.getElementById('profileSelect').addEventListener('change', function () {
        switchProfile(this.value);
    });

    document.getElementById('createProfileButton').addEventListener('click', createProfile);
    
    
function deleteProfile() {
    const selectedIndex = parseInt(document.getElementById('profileSelect').value);
    if (!isNaN(selectedIndex) && selectedIndex >= 0 && selectedIndex < profiles.length) {
        const confirmDelete = confirm("Are you sure you want to delete this profile?");
        if (confirmDelete) {
            // Save current state if we're deleting the currently active profile
            if (currentProfileIndex === selectedIndex) {
                saveCurrentProfileState();
            }
            
            // Remove the profile
            profiles.splice(selectedIndex, 1);
            updateProfileSelect();
            
            if (profiles.length > 0) {
                // Determine which profile to switch to
                let newIndex = Math.min(selectedIndex, profiles.length - 1);
                if (newIndex < 0) newIndex = 0;
                
                // Switch to the new profile and load its data
                document.getElementById('profileSelect').value = newIndex;
                const newProfile = profiles[newIndex];
                
                // Load the new profile's data
                currentBalanceInput.value = newProfile.balance ? formatNumberWithCommas(newProfile.balance) : '';
                feeBoxInput.value = newProfile.fee ? formatNumberWithCommas(newProfile.fee) : '';
                transactionAmountInput.value = newProfile.transactionAmount ? formatNumberWithCommas(newProfile.transactionAmount) : '';
                logDiv.innerHTML = newProfile.logEntries || '';
                
                // Update history arrays
                history = newProfile.history ? [...newProfile.history] : [];
                redoHistory = newProfile.redoHistory ? [...newProfile.redoHistory] : [];
                
                currentProfileIndex = newIndex;
            } else {
                // Reset to default state if no profiles left
                currentBalanceInput.value = '';
                feeBoxInput.value = '';
                transactionAmountInput.value = '';
                resultInput.value = '';
                logDiv.innerHTML = '';
                history = [];
                redoHistory = [];
                currentProfileIndex = null;
            }
            
            updateProfilesList();
        }
    } else {
        alert("Please select a profile to delete.");
    }
}

    document.getElementById('deleteProfileButton').addEventListener('click', deleteProfile);
// Updated saveCurrentProfileState function
function saveCurrentProfileState() {
    if (currentProfileIndex !== null && currentProfileIndex !== '' && profiles[currentProfileIndex]) {
        const currentProfile = profiles[currentProfileIndex];
        
        currentProfile.balance = parseFloat(currentBalanceInput.value.replace(/,/g, '')) || 0;
        currentProfile.fee = parseFloat(feeBoxInput.value.replace(/,/g, '')) || 0;
        currentProfile.transactionAmount = parseFloat(transactionAmountInput.value.replace(/,/g, '')) || 0;
        currentProfile.history = history ? [...history] : [];
        currentProfile.redoHistory = redoHistory ? [...redoHistory] : [];
        currentProfile.logEntries = logDiv.innerHTML;  // Ensure this is saved
        
        // Save last top-up amount to the current profile
        if (lastTopUpAmount > 0) {
            currentProfile.lastTopUpAmount = lastTopUpAmount;
        }
    }
}
const balanceTypeButton = document.getElementById('balanceTypeButton');
let balanceType = 'First'; // Default state

balanceTypeButton.addEventListener('click', () => {
    balanceType = balanceType === 'First' ? 'Last' : 'First';
    balanceTypeButton.textContent = balanceType;
    
    // Toggle the class for styling
    balanceTypeButton.classList.toggle('last-state');
    
    // Save state if needed
    saveAllData();
});
    // Add from Clipboard Button Event Listener
 document.getElementById('addToCurrentBalanceButton').addEventListener('click', async () => {
    let clipboardText;
    try {
        clipboardText = await navigator.clipboard.readText();
    } catch (err) {
        alert("Failed to read clipboard contents: " + err);
        return;
    }

    const clipboardValue = parseFloat(clipboardText.replace(/,/g, '')) || 0;
    const currentBalance = parseFloat(currentBalanceInput.value.replace(/,/g, '')) || 0;
    const newBalance = currentBalance + clipboardValue;

    lastTopUpAmount = clipboardValue;
    updateLastTopUpDisplay();
    
    history.push(saveCurrentState());
    redoHistory = [];
    currentBalanceInput.value = formatNumberWithCommas(newBalance);

    const timestamp = new Date();
    const timeString = `${timestamp.getHours().toString().padStart(2, '0')}:${timestamp.getMinutes().toString().padStart(2, '0')}:${timestamp.getSeconds().toString().padStart(2, '0')}`;
    const logEntry = `<span style="color: green;">${formatNumberWithCommas(currentBalance)} + ${formatNumberWithCommas(clipboardValue)} = ${formatNumberWithCommas(newBalance)} [${timeString}]</span>`;
    logDiv.innerHTML = `<div class="log-entry">${logEntry}</div>${logDiv.innerHTML}`;
    resultInput.value = `${formatNumberWithCommas(currentBalance)} + ${formatNumberWithCommas(clipboardValue)} = ${formatNumberWithCommas(newBalance)}`;

    saveCurrentProfileState();
    updateProfilesList();
});

    // Done Button Event Listener
    doneButton.addEventListener('click', async () => {
        let clipboardText;
        try {
            clipboardText = await navigator.clipboard.readText();
        } catch (err) {
            alert("Failed to read clipboard contents: " + err);
            return;
        }

        const transactionAmount = parseFloat(clipboardText.replace(/,/g, '')) || 0;
        const currentBalance = parseFloat(currentBalanceInput.value.replace(/,/g, '')) || 0;
        const fee = parseFloat(feeBoxInput.value.replace(/,/g, '')) || 0;
        let result = currentBalance - fee - transactionAmount;
        const formattedResult = formatNumberWithCommas(result);

        await navigator.clipboard.writeText(formattedResult);

        const timestamp = new Date();
        const timeString = `${timestamp.getHours().toString().padStart(2, '0')}:${timestamp.getMinutes().toString().padStart(2, '0')}:${timestamp.getSeconds().toString().padStart(2, '0')}`;
        const logEntry = fee === 0 ?
            `${formatNumberWithCommas(currentBalance)} - ${formatNumberWithCommas(transactionAmount)} = ${formattedResult} [${timeString}]` :
            `${formatNumberWithCommas(currentBalance)} - ${formatNumberWithCommas(fee)} - ${formatNumberWithCommas(transactionAmount)} = ${formattedResult} [${timeString}]`;

        logDiv.innerHTML = `<div class="log-entry"><span>${logEntry}</span></div>${logDiv.innerHTML}`;
        transactionAmountInput.value = '';
        feeBoxInput.value = fee === 0 ? '' : formatNumberWithCommas(fee);

        history.push(saveCurrentState());
        redoHistory = [];
        currentBalanceInput.value = formattedResult;
        updateResultBox(logEntry);

        saveCurrentProfileState();
        updateProfilesList(); // Added to update profile list
    });

    function updateResultBox(logEntry) {
        const regex = /(\d{1,3}(?:,\d{3})*(?:\.\d+)?|\d+)\s*-\s*(\d{1,3}(?:,\d{3})*(?:\.\d+)?|\d+)\s*=\s*(\d{1,3}(?:,\d{3})*(?:\.\d+)?|\d+)/;
        const match = logEntry.match(regex);
        
        if (match) {
            resultInput.value = `${match[1]} - ${match[2]} = ${match[3]}`;
        }
    }

    // Function to update the profiles list display
function updateProfilesList() {
    const profilesList = document.getElementById('profilesList');
    profilesList.innerHTML = '';
    
    if (profiles.length === 0) {
        profilesList.innerHTML = '<p>No profiles created yet</p>';
        return;
    }
    
    // Get current balance value (remove commas for calculation)
    const currentBalanceValue = parseFloat(currentBalanceInput.value.replace(/,/g, '')) || 0;
    
   // Create profile item
profiles.forEach((profile, index) => {
    const profileItem = document.createElement('div');
    profileItem.className = 'profile-item';
    
    // Highlight if current profile
    if (index === currentProfileIndex) {
        profileItem.classList.add('selected-profile');
    }
    
    // Create checkbox
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.className = 'profile-checkbox';
    checkbox.id = `profile-${index}`;
    checkbox.setAttribute('data-index', index);

    // Create profile info container
    const profileInfo = document.createElement('div');
    profileInfo.className = 'profile-info';
    profileInfo.innerHTML = `
        <span class="profile-name">${profile.name}</span>
        <span class="profile-balance">${formatNumberWithCommas(profile.balance)}</span>
    `;
    
    // Add click handler for profile switching
    profileItem.addEventListener('click', (e) => {
        // Only switch profile if not clicking on checkbox
        if (e.target.tagName !== 'INPUT') {
            document.getElementById('profileSelect').value = index;
            switchProfile(index);
        }
    });
    
    // Append elements
    profileItem.appendChild(checkbox);
    profileItem.appendChild(profileInfo);
    profilesList.appendChild(profileItem);
});
    
 
}
    // Function to copy all profiles to clipboard
function copyProfilesToClipboard() {
    const checkboxes = document.querySelectorAll('.profile-checkbox');
    let selectedProfiles = [];
    
    // Get all checked profiles
    checkboxes.forEach(checkbox => {
        if (checkbox.checked) {
            const index = parseInt(checkbox.getAttribute('data-index'));
            selectedProfiles.push(profiles[index]);const balanceLabel = balanceType;

        }
    });
    
    if (selectedProfiles.length === 0) {
        alert("Please check the boxes next to profiles you want to copy.");
        return;
    }
    
    const boFilter = document.getElementById('profileFilter').value.trim();
    const balanceLabel = balanceType;

    
    let profileText = '';
    
    selectedProfiles.forEach(profile => {
        if (boFilter) {
            const cleanName = profile.name.replace(/BO\d+\s*-?\s*/i, '').trim();
            profileText += `${boFilter} - ${cleanName} - ${balanceLabel} : ${formatNumberWithCommas(profile.balance)} VND\n`;
        } else {
            const boMatch = profile.name.match(/(BO\d+)(?:\s*-\s*)?(.+)?/i);
            if (boMatch) {
                const boID = boMatch[1];
                const profileName = boMatch[2] || profile.name.replace(boMatch[1], '').replace(/^\s*-\s*/, '').trim();
                profileText += `${boID} - ${profileName} - ${balanceLabel} : ${formatNumberWithCommas(profile.balance)} VND\n`;
            } else {
                profileText += `${profile.name} - ${balanceLabel} : ${formatNumberWithCommas(profile.balance)} VND\n`;
            }
        }
    });
    
    navigator.clipboard.writeText(profileText.trim()).then(() => {
        const copyButton = document.getElementById('copyProfilesButton');
        copyButton.textContent = '✓ ';
        setTimeout(() => {
            copyButton.textContent = '🗒️';
        }, 2000);
        
        showCopyMessage(`Copied ${selectedProfiles.length} profile(s) with ${balanceLabel}`);
    }).catch(err => {
        console.error("Failed to copy:", err);
        showCopyMessage("Failed to copy to clipboard");
    });
}
    document.getElementById('copyProfilesButton').addEventListener('click', copyProfilesToClipboard);

    // Profile visibility toggle
    const toggleProfilesButton = document.getElementById('toggleProfilesButton');
    const profilesContainer = document.querySelector('.profiles-container');
    let profilesVisible = false;
    profilesContainer.style.display = 'none';

    toggleProfilesButton.addEventListener('click', () => {
        profilesVisible = !profilesVisible;
        profilesContainer.style.display = profilesVisible ? 'block' : 'none';
        document.querySelector('.main-wrapper').style.maxWidth = profilesVisible ? '800px' : '480px';
        toggleProfilesButton.textContent = profilesVisible ? '👥' : '👤';
        
        if (mainWrapper.style.position === 'absolute') {
            const viewportWidth = window.innerWidth;
            const wrapperWidth = mainWrapper.offsetWidth;
            const currentLeft = parseInt(mainWrapper.style.left) || 0;
            
            if (currentLeft + wrapperWidth > viewportWidth) {
                mainWrapper.style.left = `${viewportWidth - wrapperWidth - 20}px`;
            }
        }
    });

    // Drag functionality
    const dragButton = document.getElementById('dragButton');
    const mainWrapper = document.querySelector('.main-wrapper');
    let isDragging = false;
    let offsetX, offsetY;

    dragButton.addEventListener('mousedown', (e) => {
        isDragging = true;
        offsetX = e.clientX - mainWrapper.getBoundingClientRect().left;
        offsetY = e.clientY - mainWrapper.getBoundingClientRect().top;
        mainWrapper.style.cursor = 'grabbing';
    });

    document.addEventListener('mousemove', (e) => {
        if (isDragging) {
            let newX = e.clientX - offsetX;
            let newY = e.clientY - offsetY;

            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const wrapperWidth = mainWrapper.offsetWidth;
            const wrapperHeight = mainWrapper.offsetHeight;

            newX = Math.max(0, Math.min(newX, viewportWidth - wrapperWidth));
            newY = Math.max(0, Math.min(newY, viewportHeight - wrapperHeight));

            mainWrapper.style.position = 'absolute';
            mainWrapper.style.left = `${newX}px`;
            mainWrapper.style.top = `${newY}px`;
        }
    });

    document.addEventListener('mouseup', () => {
        isDragging = false;
        mainWrapper.style.cursor = '';
    });

    // Mobile detection
    function isMobileDevice() {
        return (typeof window.orientation !== "undefined") || (navigator.userAgent.indexOf('IEMobile') !== -1);
    }

    if (isMobileDevice()) {
        profilesVisible = false;
        profilesContainer.style.display = 'none';
        toggleProfilesButton.textContent = '👤';
        document.querySelector('.main-wrapper').style.maxWidth = '480px';
    }

    // Initialize
    window.onload = function() {
        updateProfileSelect();
        updateProfilesList();
    };
    
    // Add this after your other event listeners
document.getElementById('selectAllButton').addEventListener('click', function() {
    const checkboxes = document.querySelectorAll('.profile-checkbox');
    const allChecked = Array.from(checkboxes).every(checkbox => checkbox.checked);
    
    checkboxes.forEach(checkbox => {
        checkbox.checked = !allChecked;
    });
});
// Add this utility function
async function copyToClipboard(text) {
    try {
        await navigator.clipboard.writeText(text);
        console.log("Copied to clipboard:", text);
        return true;
    } catch (err) {
        console.error("Failed to copy:", err);
        return false;
    }
}

// Then modify extractAndCopyProfileId to use it:
async function extractAndCopyProfileId(profileName) {
    // Adjust this pattern to match your ID format
    const idMatch = profileName.match(/^(BO\d+|.{15})/);
    if (idMatch && idMatch[1]) {
        const profileId = idMatch[1];
        const success = await copyToClipboard(profileId);
        if (!success) {
            console.warn("Couldn't copy automatically - please manually copy:", profileId);
        }
    }
}
// Add this at the top of your script (with other global variables)
let copyMessageTimeout = null;

// Updated extractAndCopySegment function
async function extractAndCopySegment(profileName) {
    // Clear any pending timeout
    if (copyMessageTimeout) {
        clearTimeout(copyMessageTimeout);
    }
    
    // Get message element or create it
    let messageElement = document.getElementById('copy-message');
    if (!messageElement) {
        messageElement = document.createElement('div');
        messageElement.id = 'copy-message';
        document.body.appendChild(messageElement);
    }
    
    // Split by common delimiters
    const segments = profileName.split(/[\s\-_]/).filter(segment => segment.length >= 15);
    
    if (segments.length > 0) {
        // Take first segment that's 15+ characters
        const segmentToCopy = segments[0].substring(0, 15);
        try {
            await navigator.clipboard.writeText(segmentToCopy);
            showCopyMessage(`Copied: ${segmentToCopy}`);
        } catch (err) {
            console.error("Failed to copy segment:", err);
            showCopyMessage("Failed to copy segment");
        }
    }
}

// New function to show copy message
function showCopyMessage(message) {
    const messageElement = document.getElementById('copy-message');
    messageElement.textContent = message;
    messageElement.style.display = 'block';
    
    // Hide after 2 seconds
    copyMessageTimeout = setTimeout(() => {
        messageElement.style.display = 'none';
    }, 2000);
}

// Save all data to localStorage
function saveAllData() {
    // Save current profile state before saving all data
    saveCurrentProfileState();
    
    const dataToSave = {
        profiles: profiles,
        currentProfileIndex: currentProfileIndex,
        darkMode: document.body.classList.contains('dark-mode'),
        timerInput: timerInput.value,
        timerDisplay: timerDisplay.textContent,
        syncTimerDisplay: syncTimerDisplay.textContent,
        isTimerRunning: isTimerRunning,
        currentBalance: currentBalanceInput.value,
        lastTopUpAmount: lastTopUpAmount
    };
    localStorage.setItem('r2000Data', JSON.stringify(dataToSave));
}
// Load all data from localStorage
function loadAllData() {
    const savedData = localStorage.getItem('r2000Data');
    if (savedData) {
        const parsedData = JSON.parse(savedData);
        
        // Load auto copy preference
        autoCopyEnabled = localStorage.getItem('autoCopyEnabled') === 'true';
        document.getElementById('copyToggleButton').textContent = autoCopyEnabled ? '☻' : '☺';
        
        // Restore profiles and current profile index
        profiles = parsedData.profiles || [];
        currentProfileIndex = parsedData.currentProfileIndex || 0;
        
        // Restore dark mode
        if (parsedData.darkMode) {
            document.body.classList.add('dark-mode');
            darkModeButton.textContent = '☾';
        } else {
            darkModeButton.textContent = '☀︎';
        }
        
        // Restore timer state
        timerInput.value = parsedData.timerInput || '';
        timerDisplay.textContent = parsedData.timerDisplay || '00:00';
        syncTimerDisplay.textContent = parsedData.syncTimerDisplay || '00:00';
        isTimerRunning = parsedData.isTimerRunning || false;
        
        // Set current balance to first profile's balance if available
        if (profiles.length > 0) {
            const profileSelect = document.getElementById('profileSelect');
            profileSelect.value = currentProfileIndex;
            
            const currentProfile = profiles[currentProfileIndex];
            currentBalanceInput.value = currentProfile.balance ? formatNumberWithCommas(currentProfile.balance) : '';
            feeBoxInput.value = currentProfile.fee ? formatNumberWithCommas(currentProfile.fee) : '';
            transactionAmountInput.value = currentProfile.transactionAmount ? formatNumberWithCommas(currentProfile.transactionAmount) : '';
            
            // Restore the log entries
            logDiv.innerHTML = currentProfile.logEntries || '';
            
            // Restore history
            history = currentProfile.history ? [...currentProfile.history] : [];
            redoHistory = currentProfile.redoHistory ? [...currentProfile.redoHistory] : [];
        } else {
            currentBalanceInput.value = parsedData.currentBalance || '';
        }
        
        // Restore last top-up amount
        lastTopUpAmount = parsedData.lastTopUpAmount || 0;
        if (lastTopUpAmount > 0) {
            document.getElementById('lastTopUpAmount').textContent = `+${formatNumberWithCommas(lastTopUpAmount)}`;
        }
        
        // Update UI
        updateProfileSelect();
        updateProfilesList();
        
        // Load profiles position preference
        const position = localStorage.getItem('profilesPosition');
        const mainWrapper = document.querySelector('.main-wrapper');
        
        if (position === 'left') {
            profilesOnRight = false;
            mainWrapper.classList.add('profiles-left');
        } else {
            profilesOnRight = true;
            mainWrapper.classList.add('profiles-right');
        }
        
        // Restore balance type button state
        const balanceType = localStorage.getItem('balanceType') || 'First';
        balanceTypeButton.textContent = balanceType;
        if (balanceType === 'Last') {
            balanceTypeButton.classList.add('last-state');
        }
    } else {
        // Initialize with default values if no saved data exists
        profiles = [];
        currentProfileIndex = null;
        lastTopUpAmount = 0;
        updateProfileSelect();
        updateProfilesList();
    }
}
currentBalanceInput.addEventListener('input', () => {
    saveAllData();
});
window.addEventListener('DOMContentLoaded', () => {
    loadAllData();
    updateProfileSelect();
    updateProfilesList();
    setupDragAndDrop(); // Add this line
});
    currentBalanceInput.addEventListener('input', () => {
    saveAllData(); // Auto-save on balance change
});
// Add this with your other variable declarations
let profilesOnRight = true;

// Add this event listener
document.getElementById('togglePositionButton').addEventListener('click', function() {
    const mainWrapper = document.querySelector('.main-wrapper');
    profilesOnRight = !profilesOnRight;
    
    if (profilesOnRight) {
        mainWrapper.classList.remove('profiles-left');
        mainWrapper.classList.add('profiles-right');
    } else {
        mainWrapper.classList.remove('profiles-right');
        mainWrapper.classList.add('profiles-left');
    }
    
    // Save the position preference
    localStorage.setItem('profilesPosition', profilesOnRight ? 'right' : 'left');
});

// Add this to your loadAllData function (or create a new loadPreferences function)
function loadPreferences() {
    const position = localStorage.getItem('profilesPosition');
    const mainWrapper = document.querySelector('.main-wrapper');
    
    if (position === 'left') {
        profilesOnRight = false;
        mainWrapper.classList.add('profiles-left');
    } else {
        profilesOnRight = true;
        mainWrapper.classList.add('profiles-right');
    }
}

// Call this when the page loads (add to your window.onload or DOMContentLoaded event)
loadPreferences();
document.getElementById('updateCheckedButton').addEventListener('click', function() {
    const checkboxes = document.querySelectorAll('.profile-checkbox:checked');
    const currentBalance = parseFloat(currentBalanceInput.value.replace(/,/g, '')) || 0;
    
    checkboxes.forEach(checkbox => {
        const index = parseInt(checkbox.getAttribute('data-index'));
        profiles[index].balance = currentBalance;
    });
    
    updateProfilesList();
    saveAllData();
});
// Get the BO ID input and heading elements
const profileFilterInput = document.getElementById('profileFilter');
const profilesHeading = document.getElementById('profilesHeading');

// Update heading when BO ID is typed
profileFilterInput.addEventListener('input', function() {
    const boId = this.value.trim();
    if (boId) {
        profilesHeading.innerHTML = `Profiles <span class="bo-id">(${boId})</span>`;
    } else {
        profilesHeading.textContent = 'All Profiles';
    }
});
// Add this with your other variable declarations
let draggedItem = null;
let draggedIndex = null;

// Add this function to set up drag and drop
function setupDragAndDrop() {
    const profilesList = document.getElementById('profilesList');
    
    // Make each profile item draggable
    document.querySelectorAll('.profile-item').forEach(item => {
        item.setAttribute('draggable', 'true');
        
        item.addEventListener('dragstart', function(e) {
            draggedItem = this;
            draggedIndex = Array.from(this.parentNode.children).indexOf(this);
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.innerHTML);
        });
        
        item.addEventListener('dragend', function() {
            this.classList.remove('dragging');
        });
    });
    
    // Handle drag over
    profilesList.addEventListener('dragover', function(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        
        const afterElement = getDragAfterElement(profilesList, e.clientY);
        const currentItem = document.querySelector('.dragging');
        
        if (afterElement == null) {
            profilesList.appendChild(currentItem);
        } else {
            profilesList.insertBefore(currentItem, afterElement);
        }
    });
    
    // Handle drop
    profilesList.addEventListener('drop', function(e) {
        e.preventDefault();
        
        if (draggedItem) {
            const newIndex = Array.from(profilesList.children).indexOf(draggedItem);
            
            // Only update if position changed
            if (newIndex !== draggedIndex) {
                // Move the profile in the array
                const movedProfile = profiles.splice(draggedIndex, 1)[0];
                profiles.splice(newIndex, 0, movedProfile);
                
                // Update currentProfileIndex if needed
                if (currentProfileIndex === draggedIndex) {
                    currentProfileIndex = newIndex;
                } else if (currentProfileIndex > draggedIndex && currentProfileIndex <= newIndex) {
                    currentProfileIndex--;
                } else if (currentProfileIndex < draggedIndex && currentProfileIndex >= newIndex) {
                    currentProfileIndex++;
                }
                
                // Update the select dropdown
                updateProfileSelect();
                saveAllData();
            }
        }
    });
}

// Helper function to determine drop position
function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.profile-item:not(.dragging)')];
    
    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        
        if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}
</script>
